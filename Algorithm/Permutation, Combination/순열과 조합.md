# 순열과 조합

## 1. 순열

서로 다른 n개의 원소에서 r 개를 **중복없이** 골라 **순서를 고려하여** 나열하는 것.

- 순열을 고려할 데이터에서 중복이 없다는 것을 전제로 한다.
- 순서를 고려하므로 같은 데이터라도 순서가 다르면 다른 결과로 고려한다.



**그렇다면 어떻게 알고리즘으로 구현 할 것인가?**

직접 순열을 만들 때 방식을 그대로 생각하면

1.  첫 번째 순서로 올 원소를 지정한다 (n개 중 n개)
2.  두 번째 순서로 올 원소는 첫 번째 순서에 뽑힌 원소를 제외하고 지정한다 (n개 중 n-1개)
3.  반복..



일단 n개 원소에서 n개를 뽑는 순열을 구현하기 위해서

```d
data = [1, 2, 3, 4]
```

순열을 구할 임의의 data 리스트를 만든다



위 방식에서 **n 번째 순서로 올 원소를 지정** 하기위해서 

data 리스트와 길이가 같은 boolean 원소가 들어있는 리스트를 활용한다.

```python
bit = [False for i in range(len(data))]
```

이 bit 리스트를 활용해 이후에 `bit[i]` 가 `True`면 해당 순서의 자리에 선택된 것으로 본다.



순열을 만들기 위해서 함수의 재귀를 이용한다.

해당하는 순서의 원소를 뽑고 다음 호출시 덧붙이는 방식으로 기존 data 원소의 수만큼 뽑을 것이므로 

1. data 리스트의 크기

2. 현재까지의 순열

두 가지를 인자로 전달한다.

```python
def permutation(n, result):
    # n : data배열 길이
    # result : 현재까지 순열
    if len(result) == n:
        # 결과 수행
        
    else:
        for i in range(n):
            if bit[i] is False:
                bit[i] = True
                permutation(n, result + [data[i]])
                bit[i] = False
```

```python
data = [1, 2, 3, 4]
```

data는 위 처럼 길이가 4인 리스트이므로

``` python
permutation(len(data), [])
```

위 인자로 함수를 호출한다.



`permutaiton`함수는 result (순열)가 data 길이만큼 뽑힐 때 까지 아래 `else` 구문을 재귀수행하는데

data의 각 인덱스 중 이미 result에 선택 (`bit[i] == True`) 되지 않은 원소들을 하나씩 선택하고

각 경우를 다시 다음 함수에 전달한다. 

이때 하나가 선택된 경우를 모두 수행후 `bit[i] == False` 를 수행하여 다음 원소가 선택되었을 때

그 전단계에서 선택된 원소가 다른 순서에 선택될 수 있게 한다.

즉, 첫 실행시

> result = [1] 인 상태로 `permutation(4, [1])`을 호출
>
> result = [2] 인 상태로 `permutation(4, [2])`을 호출
>
> result = [3] 인 상태로 `permutation(4, [3])`을 호출
>
> result = [4] 인 상태로 `permutation(4, [4])`을 호출



이때 result = [1] 인 경우만 보면

> `permutation(4, [1])`이 호출되면 해당 함수가 종료되기 전 까지는 `bit[0] = True` 이다.
>
> 그렇기 때문에 첫 순서로 `data[0](==1)`이 오는 모든 경우의 수 에서 다른 순서에 `data[0](==1)` 이 오지 않는다.
>
> 하지만 첫 순서로 `data[0]`이 오는 모든 경우가 끝나면 ( = `permutation(4, [1])`이 `return`되면) 다시 `bit[i] = False`가 실행된다. 그래서 `for`문에 의한 다음 호출인 `permutation(4, [2])`가 실행되는 경우에서는 `data[0]`이 다음 순서로 고려될 수 있다.



위 과정이 반복되어 서로 순서가 다른 모든 경우를 고려할 수 있다.

위 코드의 실행 결과는 아래와 같다

```
[1, 2, 3, 4]
[1, 2, 4, 3]
[1, 3, 2, 4]
[1, 3, 4, 2]
[1, 4, 2, 3]
[1, 4, 3, 2]
[2, 1, 3, 4]
[2, 1, 4, 3]
[2, 3, 1, 4]
[2, 3, 4, 1]
[2, 4, 1, 3]
[2, 4, 3, 1]
[3, 1, 2, 4]
[3, 1, 4, 2]
[3, 2, 1, 4]
[3, 2, 4, 1]
[3, 4, 1, 2]
[3, 4, 2, 1]
[4, 1, 2, 3]
[4, 1, 3, 2]
[4, 2, 1, 3]
[4, 2, 3, 1]
[4, 3, 1, 2]
[4, 3, 2, 1]
```

위 코드를 그대로 활용하면 nPn 뿐만 아니라 nPr도 구할 수 있는데

`permutation(r, [])` 에 원하는 r (0 < r <= n) 을 넣으면 된다.



---



## 2. 중복순열

중복순열은 n개의 원소에서 **중복을 허용해서**  **순서를 고려해** 나열하는 것이다.

즉, 이미 앞에서 뽑힌 원소라고 하더라도 뒤에 한번 더 뽑힐 수 있다는 것이고 위 순열 코드를 활용하여 간단히 만들 수 있다.



위의 순열 코드에서 중복을 제거하기 위한 부분은

```python
0 for i in range(n):
1     if bit[i] is False:
2         bit[i] = True
3         permutation(n, result + [data[i]])
4         bit[i] = False
```

`for` 문 내부에 있는 `if` 부분이다.

`if bit[i] is False:` 로 인해서 뽑히지 않는 원소만 다음 원소로 고려하게 되기 때문에 위 `if` 만 제거해주면 간단히 중복순열을 구현할 수 있다



```python
def permutation_multi(n, result):
    if len(result) == n:
        # 결과 수행
        print(result)
    else:
        for i in range(len(data)):
            bit[i] = True
            permutation_multi(n, result + [data[i]])
            bit[i] = False
```



**다만 위 두가지 경우는 data 내에 중복이 존재하는 경우에는 중복을 제거하지 못한다.**



---



## 3. 조합

서로 다른 n 개의 원소에서 **순서를 고려하지 않고** r 개의 원소를 뽑는 것.

따라서 결과의 원소의 종류가 동일하다면 뽑힌 순서를 생각하지 않고 같은 결과로 생각한다.

> 예) [1, 2, 3]과 [2, 1, 3]은 같은 결과



그렇기 때문에 전에 했던 부분집합 만들기에서 그 원소의 개수가 원하는 수가 되었을 때 처리해 주면 된다.

```python
def comb(k, r, n, result):
    if k >= n:
        return
    if len(result) == r:
        # 결과 수행
        print(result)
    else:
        comb(k+1, r, n, result)
        comb(k+1, r, n, result+[data[k]])

data = [1, 2, 3, 4, 5]
bit = [False for i in range(len(data))]

comb(0, 3, 5, [])
```

위 `comb()`함수는 인자로 `k`,`r`, `n`, `result` 를 받는데

`k` 는 조합을 만들기 원하는 data를 어디까지 탐색했느냐

`r` 은 내가 뽑기 원하는 수

`n` 은 조합을 만들기 원하는 data의 크기

`result` 는 현재까지의 결과값을 담은 변수이다.



```
[2, 3, 4]
[1, 3, 4]
[1, 2, 4]
[1, 2, 3]
```



---



## 4. 중복조합

